<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++)
        filterItems[i].hidden = false;
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>pytest_report.html</h1>
    <p>Report generated on 18-Oct-2022 at 00:51:47 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.1.1</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{"pluggy": "1.0.0", "py": "1.11.0", "pytest": "7.1.3"}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Linux-5.15.0-50-generic-x86_64-with-glibc2.35</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{"html": "3.1.1", "metadata": "2.0.2"}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.10.6</td></tr></table>
    <h2>Summary</h2>
    <p>1 tests ran in 17.37 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">0 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">1 failed</span>, <input checked="true" class="filter" data-test-result="error" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">25 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable time" col="time">Time</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractPermissions::test_permissions_at_creation::setup</td>
          <td class="col-duration">2.31</td>
          <td class="col-time">2022-10-17 22:51:47.334533</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractPermissions object at 0x7f86d3a6d360&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d3592200&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d35ccd30&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction VOG654AEVQMFTHXOWEJO4FDVEXVEROYSWAHKIK6J6WKYLEDYIPXA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/> -----------------------------Captured stderr setup------------------------------ <br/>[conftest.py:79 -        sandbox_setup() ] --sandbox argument not provided -&gt; skipping sandbox setup...
[test_contract.py:247 -          debug_print() ] Class configuration:
{&#x27;event_end_since_test_start_s&#x27;: 2,
 &#x27;payout_time_s&#x27;: 2,
 &#x27;session_start_s&#x27;: 1666047090.231713}
[test_contract.py:221 -             app_addr() ] Creating the application...
<br/> -------------------------------Captured log setup------------------------------- <br/>INFO     src.test.conftest:conftest.py:79 --sandbox argument not provided -&gt; skipping sandbox setup...
DEBUG    src.test.conftest:test_contract.py:247 Class configuration:
{&#x27;event_end_since_test_start_s&#x27;: 2,
 &#x27;payout_time_s&#x27;: 2,
 &#x27;session_start_s&#x27;: 1666047090.231713}
DEBUG    src.test.conftest:test_contract.py:221 Creating the application...<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractPermissions::test_opt_in_creator::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.338899</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractPermissions object at 0x7f86d3a6d360&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d3592200&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d35ccd30&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction VOG654AEVQMFTHXOWEJO4FDVEXVEROYSWAHKIK6J6WKYLEDYIPXA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractPermissions::test_opt_in_participant::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.343745</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractPermissions object at 0x7f86d3a6d360&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d3592200&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d35ccd30&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction VOG654AEVQMFTHXOWEJO4FDVEXVEROYSWAHKIK6J6WKYLEDYIPXA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractPermissions::test_opt_in_oracle::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.348264</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractPermissions object at 0x7f86d3a6d360&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d3592200&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d35ccd30&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction VOG654AEVQMFTHXOWEJO4FDVEXVEROYSWAHKIK6J6WKYLEDYIPXA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractPermissions::test_set_result_from_non_authorized::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.352814</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractPermissions object at 0x7f86d3a6d360&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d3592200&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d35ccd30&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction VOG654AEVQMFTHXOWEJO4FDVEXVEROYSWAHKIK6J6WKYLEDYIPXA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractPermissions::test_delete_from_non_authorized::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.357365</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2f63760&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2f63760&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2f633d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2eb62c0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractPermissions object at 0x7f86d3a6d360&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d3592200&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d35ccd30&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@&amp;\r~\xe5ivk\x86f\xad|\xcan\xf5.D&lt;\xdc;\x10: \xa5\x1e\xd3\xcd\xd3\xe8\xa1\xfd\xc2\x99\xc2\xdf\xcb\x8d...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction VOG654AEVQMFTHXOWEJO4FDVEXVEROYSWAHKIK6J6WKYLEDYIPXA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_participants_opt_in::setup</td>
          <td class="col-duration">2.29</td>
          <td class="col-time">2022-10-17 22:51:47.364645</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/> -----------------------------Captured stderr setup------------------------------ <br/>[test_contract.py:247 -          debug_print() ] Class configuration:
{&#x27;event_end_since_test_start_s&#x27;: 10,
 &#x27;payout_time_s&#x27;: 10,
 &#x27;session_start_s&#x27;: 1666047090.2320673}
[test_contract.py:221 -             app_addr() ] Creating the application...
<br/> -------------------------------Captured log setup------------------------------- <br/>DEBUG    src.test.conftest:test_contract.py:247 Class configuration:
{&#x27;event_end_since_test_start_s&#x27;: 10,
 &#x27;payout_time_s&#x27;: 10,
 &#x27;session_start_s&#x27;: 1666047090.2320673}
DEBUG    src.test.conftest:test_contract.py:221 Creating the application...<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_make_bet_wrong_stack::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.369173</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_make_bet_wrong_option::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.373770</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_make_bets::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.378291</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_make_bets_twice::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.383492</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_request_payout_before_event_end::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.387623</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_oracle_set_result_before_event_end::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.391808</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_request_payout_before_event_results::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.395931</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_oracle_set_result_after_event_end::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.400801</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_request_payout_looser::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.404943</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_request_payout_winners::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.409074</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_request_payout_winners_again::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.413225</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_request_deletion_before_payout_time::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.418075</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractFlow::test_request_deletion_after_payout_time::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.422208</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2d878e0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2d878e0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2d86170&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2d86c50&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractFlow object at 0x7f86d3a6df90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2caa050&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d2bc2230&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@\xe4}\xb7W\x90%\xd7\xad\x88?\x18\xb6g\xc3&lt;e\xaazF@&quot;\xcc6b\xcft/\xd2R.\x11\xf7h8\xba\xf9\x02\x83\xed\...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction 77V272BNAFGAK3OFNZC67PVHLLUNDQNGJ3QX3ZWZQ57DMUJTMYOA: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractNoWinners::test_participants_opt_in::setup</td>
          <td class="col-duration">2.01</td>
          <td class="col-time">2022-10-17 22:51:47.426349</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractNoWinners object at 0x7f86d3575f90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2f62fb0&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d31bae00&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction YHGSB24VIOXLGWJ4JPBS3MX2E5LQ4WGN4Y4MHAGXUGK4CPMHZVUQ: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/> -----------------------------Captured stderr setup------------------------------ <br/>[test_contract.py:247 -          debug_print() ] Class configuration:
{&#x27;event_end_since_test_start_s&#x27;: 2,
 &#x27;payout_time_s&#x27;: 2,
 &#x27;session_start_s&#x27;: 1666047090.2608552}
[test_contract.py:221 -             app_addr() ] Creating the application...
<br/> -------------------------------Captured log setup------------------------------- <br/>DEBUG    src.test.conftest:test_contract.py:247 Class configuration:
{&#x27;event_end_since_test_start_s&#x27;: 2,
 &#x27;payout_time_s&#x27;: 2,
 &#x27;session_start_s&#x27;: 1666047090.2608552}
DEBUG    src.test.conftest:test_contract.py:221 Creating the application...<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractNoWinners::test_make_bets::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.430437</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractNoWinners object at 0x7f86d3575f90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2f62fb0&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d31bae00&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction YHGSB24VIOXLGWJ4JPBS3MX2E5LQ4WGN4Y4MHAGXUGK4CPMHZVUQ: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractNoWinners::test_oracle_set_result_after_event_end::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.435207</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractNoWinners object at 0x7f86d3575f90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2f62fb0&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d31bae00&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction YHGSB24VIOXLGWJ4JPBS3MX2E5LQ4WGN4Y4MHAGXUGK4CPMHZVUQ: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractNoWinners::test_request_payout_winners::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.439198</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractNoWinners object at 0x7f86d3575f90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2f62fb0&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d31bae00&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction YHGSB24VIOXLGWJ4JPBS3MX2E5LQ4WGN4Y4MHAGXUGK4CPMHZVUQ: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">test_contract.py::TestContractNoWinners::test_request_deletion_after_payout_time::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-time">2022-10-17 22:51:47.443216</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>&gt;           resp = urlopen(req)<br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:78: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>url = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None, timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,<br/>                *, cafile=None, capath=None, cadefault=False, context=None):<br/>        &#x27;&#x27;&#x27;Open the URL url, which can be either a string or a Request object.<br/>    <br/>        *data* must be an object specifying additional data to be sent to<br/>        the server, or None if no such data is needed.  See Request for<br/>        details.<br/>    <br/>        urllib.request module uses HTTP/1.1 and includes a &quot;Connection:close&quot;<br/>        header in its HTTP requests.<br/>    <br/>        The optional *timeout* parameter specifies a timeout in seconds for<br/>        blocking operations like the connection attempt (if not specified, the<br/>        global default timeout setting will be used). This only works for HTTP,<br/>        HTTPS and FTP connections.<br/>    <br/>        If *context* is specified, it must be a ssl.SSLContext instance describing<br/>        the various SSL options. See HTTPSConnection for more details.<br/>    <br/>        The optional *cafile* and *capath* parameters specify a set of trusted CA<br/>        certificates for HTTPS requests. cafile should point to a single file<br/>        containing a bundle of CA certificates, whereas capath should point to a<br/>        directory of hashed certificate files. More information can be found in<br/>        ssl.SSLContext.load_verify_locations().<br/>    <br/>        The *cadefault* parameter is ignored.<br/>    <br/>    <br/>        This function always returns an object which can work as a<br/>        context manager and has the properties url, headers, and status.<br/>        See urllib.response.addinfourl for more detail on these properties.<br/>    <br/>        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse<br/>        object slightly modified. In addition to the three new methods above, the<br/>        msg attribute contains the same information as the reason attribute ---<br/>        the reason phrase returned by the server --- instead of the response<br/>        headers as it is specified in the documentation for HTTPResponse.<br/>    <br/>        For FTP, file, and data URLs and requests explicitly handled by legacy<br/>        URLopener and FancyURLopener classes, this function returns a<br/>        urllib.response.addinfourl object.<br/>    <br/>        Note that None may be returned if no handler handles the request (though<br/>        the default installed global OpenerDirector uses UnknownHandler to ensure<br/>        this never happens).<br/>    <br/>        In addition, if proxy settings are detected (for example, when a *_proxy<br/>        environment variable like http_proxy is set), ProxyHandler is default<br/>        installed and makes sure the requests are handled through the proxy.<br/>    <br/>        &#x27;&#x27;&#x27;<br/>        global _opener<br/>        if cafile or capath or cadefault:<br/>            import warnings<br/>            warnings.warn(&quot;cafile, capath and cadefault are deprecated, use a &quot;<br/>                          &quot;custom context instead.&quot;, DeprecationWarning, 2)<br/>            if context is not None:<br/>                raise ValueError(<br/>                    &quot;You can&#x27;t pass both context and any of cafile, capath, and &quot;<br/>                    &quot;cadefault&quot;<br/>                )<br/>            if not _have_ssl:<br/>                raise ValueError(&#x27;SSL support not available&#x27;)<br/>            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,<br/>                                                 cafile=cafile,<br/>                                                 capath=capath)<br/>            # send ALPN extension to indicate HTTP/1.1 protocol<br/>            context.set_alpn_protocols([&#x27;http/1.1&#x27;])<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif context:<br/>            https_handler = HTTPSHandler(context=context)<br/>            opener = build_opener(https_handler)<br/>        elif _opener is None:<br/>            _opener = opener = build_opener()<br/>        else:<br/>            opener = _opener<br/>&gt;       return opener.open(url, data, timeout)<br/><br/>/usr/lib/python3.10/urllib/request.py:216: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, fullurl = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, data = None<br/>timeout = &lt;object object at 0x7f86d64f0dd0&gt;<br/><br/>    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):<br/>        # accept a URL or a Request object<br/>        if isinstance(fullurl, str):<br/>            req = Request(fullurl, data)<br/>        else:<br/>            req = fullurl<br/>            if data is not None:<br/>                req.data = data<br/>    <br/>        req.timeout = timeout<br/>        protocol = req.type<br/>    <br/>        # pre-process request<br/>        meth_name = protocol+&quot;_request&quot;<br/>        for processor in self.process_request.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>            req = meth(req)<br/>    <br/>        sys.audit(&#x27;urllib.Request&#x27;, req.full_url, req.data, req.headers, req.get_method())<br/>        response = self._open(req, data)<br/>    <br/>        # post-process response<br/>        meth_name = protocol+&quot;_response&quot;<br/>        for processor in self.process_response.get(protocol, []):<br/>            meth = getattr(processor, meth_name)<br/>&gt;           response = meth(req, response)<br/><br/>/usr/lib/python3.10/urllib/request.py:525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPErrorProcessor object at 0x7f86d3592530&gt;, request = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>response = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;<br/><br/>    def http_response(self, request, response):<br/>        code, msg, hdrs = response.code, response.msg, response.info()<br/>    <br/>        # According to RFC 2616, &quot;2xx&quot; code indicates that the client&#x27;s<br/>        # request was successfully received, understood, and accepted.<br/>        if not (200 &lt;= code &lt; 300):<br/>&gt;           response = self.parent.error(<br/>                &#x27;http&#x27;, request, response, code, msg, hdrs)<br/><br/>/usr/lib/python3.10/urllib/request.py:634: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;, proto = 400<br/>args = ({&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHa...ult&#x27;, &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, ...)<br/>dict = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>meth_name = &#x27;http_error_400&#x27;, http_err = 1<br/><br/>    def error(self, proto, *args):<br/>        if proto in (&#x27;http&#x27;, &#x27;https&#x27;):<br/>            # XXX http[s] protocols are special-cased<br/>            dict = self.handle_error[&#x27;http&#x27;] # https is not different than http<br/>            proto = args[2]  # YUCK!<br/>            meth_name = &#x27;http_error_%s&#x27; % proto<br/>            http_err = 1<br/>            orig_args = args<br/>        else:<br/>            dict = self.handle_error<br/>            meth_name = proto + &#x27;_error&#x27;<br/>            http_err = 0<br/>        args = (dict, proto, meth_name) + args<br/>        result = self._call_chain(*args)<br/>        if result:<br/>            return result<br/>    <br/>        if http_err:<br/>            args = (dict, &#x27;default&#x27;, &#x27;http_error_default&#x27;) + orig_args<br/>&gt;           return self._call_chain(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.OpenerDirector object at 0x7f86d3592260&gt;<br/>chain = {&#x27;default&#x27;: [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], 301: [&lt;urllib.request.HTTPRedirectHan...PRedirectHandler object at 0x7f86d35925c0&gt;], 303: [&lt;urllib.request.HTTPRedirectHandler object at 0x7f86d35925c0&gt;], ...}<br/>kind = &#x27;default&#x27;, meth_name = &#x27;http_error_default&#x27;<br/>args = (&lt;urllib.request.Request object at 0x7f86d2a000a0&gt;, &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, 400, &#x27;Bad Request&#x27;, &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;)<br/>handlers = [&lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;], handler = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;<br/>func = &lt;bound method HTTPDefaultErrorHandler.http_error_default of &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;&gt;<br/><br/>    def _call_chain(self, chain, kind, meth_name, *args):<br/>        # Handlers raise an exception if no one else should try to handle<br/>        # the request, or return None if they can&#x27;t but another handler<br/>        # could.  Otherwise, they return the response.<br/>        handlers = chain.get(kind, ())<br/>        for handler in handlers:<br/>            func = getattr(handler, meth_name)<br/>&gt;           result = func(*args)<br/><br/>/usr/lib/python3.10/urllib/request.py:496: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib.request.HTTPDefaultErrorHandler object at 0x7f86d3592320&gt;, req = &lt;urllib.request.Request object at 0x7f86d2a000a0&gt;<br/>fp = &lt;http.client.HTTPResponse object at 0x7f86d2a015d0&gt;, code = 400, msg = &#x27;Bad Request&#x27;, hdrs = &lt;http.client.HTTPMessage object at 0x7f86d2a03dc0&gt;<br/><br/>    def http_error_default(self, req, fp, code, msg, hdrs):<br/>&gt;       raise HTTPError(req.full_url, code, msg, hdrs, fp)<br/><span class="error">E       urllib.error.HTTPError: HTTP Error 400: Bad Request</span><br/><br/>/usr/lib/python3.10/urllib/request.py:643: HTTPError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;src.test.test_contract.TestContractNoWinners object at 0x7f86d3575f90&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d2f62fb0&gt;<br/>oracle_account = SandboxAccount(address=&#x27;35QK5EJ56ZNG7RAKZYBTHIYOPH2WWGF2HVFNTTEFW2B7STJPFNKHC4GIOE&#x27;, private_key=&#x27;onSShhHKYkjAlHsseeKN...Yuj1K2cyFtoP5TS8rVA==&#x27;, signer=&lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d31bae00&gt;)<br/><br/>    @pytest.fixture(scope=&quot;class&quot;)<br/>    def app_addr(self, creator_app_client, oracle_account):<br/>        &quot;&quot;&quot;Create the application on chain using the Application Client of the creator account.<br/>        `oracle_addr` parameter is set as the `oracle_account` account address.<br/>        &quot;&quot;&quot;<br/>        logger.debug(&quot;Creating the application...&quot;)<br/>&gt;       app_id, app_addr, tx_id = creator_app_client.create(<br/>            manager_addr=creator_app_client.get_sender(),<br/>            oracle_addr=oracle_account.address,  # Don&#x27;t use oracle client before app creation<br/>            event_end_unix_timestamp=int(time.time() + self.config[&quot;event_end_since_test_start_s&quot;]),<br/>            payout_time_window_s=self.config[&quot;payout_time_s&quot;],<br/>        )<br/><br/>src/test/test_contract.py:222: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:161: in create<br/>    raise e<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:156: in create<br/>    create_result = atc.execute(self.client, 4)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:483: in execute<br/>    self.submit(client)<br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:450: in submit<br/>    client.send_transactions(self.signed_txns)<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:330: in send_transactions<br/>    return self.send_raw_transaction(<br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:260: in send_raw_transaction<br/>    return self.algod_request(&quot;POST&quot;, req, data=txn, **kwargs)[&quot;txId&quot;]<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.v2client.algod.AlgodClient object at 0x7f86d3591d80&gt;, method = &#x27;POST&#x27;, requrl = &#x27;/v2/transactions&#x27;, params = None<br/>data = b&#x27;\x82\xa3sig\xc4@%2\x85&quot;\x94\xf1\xb8\xd7L?M\xd5\xd4\xae\xf7\x1e}\x92\x8a\xd4\xf4\xcab\xd4\x14p\xda!9\xb6\xd5\xe2`,vZO...nd\xc4 \xe0\x14:\xd5\xbf\xf4(yq\xa4\xc1\xd3\xc6\x19T\x04\x82\x87\xc5&amp;\xac\x80\x8c\xbfk\x86\xdb!\xa75+~\xa4type\xa4appl&#x27;<br/>headers = {&#x27;Content-Type&#x27;: &#x27;application/x-binary&#x27;}, response_format = &#x27;json&#x27;<br/><br/>    def algod_request(<br/>        self,<br/>        method,<br/>        requrl,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        response_format=&quot;json&quot;,<br/>    ):<br/>        &quot;&quot;&quot;<br/>        Execute a given request.<br/>    <br/>        Args:<br/>            method (str): request method<br/>            requrl (str): url for the request<br/>            params (dict, optional): parameters for the request<br/>            data (dict, optional): data in the body of the request<br/>            headers (dict, optional): additional header for request<br/>    <br/>        Returns:<br/>            dict: loaded from json response body<br/>        &quot;&quot;&quot;<br/>        header = {&quot;User-Agent&quot;: &quot;py-algorand-sdk&quot;}<br/>    <br/>        if self.headers:<br/>            header.update(self.headers)<br/>    <br/>        if headers:<br/>            header.update(headers)<br/>    <br/>        if requrl not in constants.no_auth:<br/>            header.update({constants.algod_auth_header: self.algod_token})<br/>    <br/>        if requrl not in constants.unversioned_paths:<br/>            requrl = api_version_path_prefix + requrl<br/>        if params:<br/>            requrl = requrl + &quot;?&quot; + parse.urlencode(params)<br/>    <br/>        req = Request(<br/>            self.algod_address + requrl,<br/>            headers=header,<br/>            method=method,<br/>            data=data,<br/>        )<br/>    <br/>        try:<br/>            resp = urlopen(req)<br/>        except urllib.error.HTTPError as e:<br/>            code = e.code<br/>            e = e.read().decode(&quot;utf-8&quot;)<br/>            try:<br/>                e = json.loads(e)[&quot;message&quot;]<br/>            finally:<br/>&gt;               raise error.AlgodHTTPError(e, code)<br/><span class="error">E               algosdk.error.AlgodHTTPError: TransactionPool.Remember: transaction YHGSB24VIOXLGWJ4JPBS3MX2E5LQ4WGN4Y4MHAGXUGK4CPMHZVUQ: overspend (account 4AKDVVN76QUHS4NEYHJ4MGKUASBIPRJGVSAIZP3LQ3NSDJZVFN7N2JSFKM, data {AccountBaseData:{Status:Offline MicroAlgos:{Raw:0} RewardsBase:0 RewardedMicroAlgos:{Raw:0} AuthAddr:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ TotalAppSchema:{_struct:{} NumUint:0 NumByteSlice:0} TotalExtraAppPages:0 TotalAppParams:0 TotalAppLocalStates:0 TotalAssetParams:0 TotalAssets:0} VotingData:{VoteID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] SelectionID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] StateProofID:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] VoteFirstValid:0 VoteLastValid:0 VoteKeyDilution:0}}, tried to spend {1000})</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/v2client/algod.py:85: AlgodHTTPError<br/> ----------------------------Captured stderr teardown---------------------------- <br/>[conftest.py:89 -        sandbox_setup() ] --sandbox argument not provided -&gt; skipping sandbox teardown...
<br/> -----------------------------Captured log teardown------------------------------ <br/>INFO     src.test.conftest:conftest.py:89 --sandbox argument not provided -&gt; skipping sandbox teardown...<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">test_contract.py::TestContractPermissions::test_app_deletion_and_close_out</td>
          <td class="col-duration">2.01</td>
          <td class="col-time">2022-10-17 22:51:47.359081</td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;src.test.test_contract.TestContractPermissions object at 0x7f86d3575630&gt;<br/>creator_app_client = &lt;beaker.client.application_client.ApplicationClient object at 0x7f86d3592200&gt;<br/>ping_sandbox = &lt;function TestBase.ping_sandbox.&lt;locals&gt;._call_dummy at 0x7f86d31b0430&gt;<br/>safe_wait_to_delete = &lt;function TestBase.safe_wait_to_delete.&lt;locals&gt;._safe_wait_to_delete at 0x7f86d31b1750&gt;<br/><br/>    def test_app_deletion_and_close_out(self, creator_app_client, ping_sandbox, safe_wait_to_delete):<br/>        # Delete the app<br/>&gt;       safe_wait_to_delete()<br/><br/>src/test/test_contract.py:394: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>src/test/test_contract.py:97: in _safe_wait_to_delete<br/>    ping_sandbox()<br/>src/test/test_contract.py:212: in _call_dummy<br/>    client.call(App.dummy)<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:469: in call<br/>    atc = self.add_method_call(<br/>venv/lib/python3.10/site-packages/beaker/client/application_client.py:634: in add_method_call<br/>    atc.add_method_call(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;algosdk.atomic_transaction_composer.AtomicTransactionComposer object at 0x7f86d31a1c60&gt;, app_id = 0<br/>method = &lt;algosdk.abi.method.Method object at 0x7f86d3546bf0&gt;, sender = &#x27;XONBDI4HRW5CW75LEBK6FTSHRXBYU6AE46CQTJRQ7ILXJMRVRSMEKXZU4A&#x27;<br/>sp = &lt;algosdk.future.transaction.SuggestedParams object at 0x7f86d31a0430&gt;<br/>signer = &lt;algosdk.atomic_transaction_composer.AccountTransactionSigner object at 0x7f86d35ccc70&gt;, method_args = [], on_complete = &lt;OnComplete.NoOpOC: 0&gt;<br/>local_schema = None, global_schema = None, approval_program = None, clear_program = None, extra_pages = None, accounts = None, foreign_apps = None<br/>foreign_assets = None, note = None, lease = None, rekey_to = None<br/><br/>    def add_method_call(<br/>        self,<br/>        app_id: int,<br/>        method: abi.Method,<br/>        sender: str,<br/>        sp: transaction.SuggestedParams,<br/>        signer: &quot;TransactionSigner&quot;,<br/>        method_args: List[Union[Any, &quot;TransactionWithSigner&quot;]] = None,<br/>        on_complete: transaction.OnComplete = transaction.OnComplete.NoOpOC,<br/>        local_schema: transaction.StateSchema = None,<br/>        global_schema: transaction.StateSchema = None,<br/>        approval_program: bytes = None,<br/>        clear_program: bytes = None,<br/>        extra_pages: int = None,<br/>        accounts: List[str] = None,<br/>        foreign_apps: List[int] = None,<br/>        foreign_assets: List[int] = None,<br/>        note: bytes = None,<br/>        lease: bytes = None,<br/>        rekey_to: str = None,<br/>    ) -&gt; &quot;AtomicTransactionComposer&quot;:<br/>        &quot;&quot;&quot;<br/>        Add a smart contract method call to this atomic group.<br/>    <br/>        An error will be thrown if the composer&#x27;s status is not BUILDING,<br/>        if adding this transaction causes the current group to exceed<br/>        MAX_GROUP_SIZE, or if the provided arguments are invalid for<br/>        the given method.<br/>    <br/>        Args:<br/>            app_id (int): application id of app that the method is being invoked on<br/>            method (Method): ABI method object with initialized arguments and return types<br/>            sender (str): address of the sender<br/>            sp (SuggestedParams): suggested params from algod<br/>            signer (TransactionSigner): signer that will sign the transactions<br/>            method_args (list[ABIValue | TransactionWithSigner], optional): list of arguments to be encoded<br/>                or transactions that immediate precede this method call<br/>            on_complete (OnComplete, optional): intEnum representing what app should do on completion<br/>                and if blank, it will default to a NoOp call<br/>            local_schema (StateSchema, optional): restricts what can be stored by created application;<br/>                must be omitted if not creating an application<br/>            global_schema (StateSchema, optional): restricts what can be stored by created application;<br/>                must be omitted if not creating an application<br/>            approval_program (bytes, optional): the program to run on transaction approval;<br/>                must be omitted if not creating or updating an application<br/>            clear_program (bytes, optional): the program to run when state is being cleared;<br/>                must be omitted if not creating or updating an application<br/>            extra_pages (int, optional): additional program space for supporting larger programs.<br/>                A page is 1024 bytes.<br/>            accounts (list[string], optional): list of additional accounts involved in call<br/>            foreign_apps (list[int], optional): list of other applications (identified by index) involved in call<br/>            foreign_assets (list[int], optional): list of assets involved in call<br/>            note (bytes, optional): arbitrary optional bytes<br/>            lease (byte[32], optional): specifies a lease, and no other transaction<br/>                with the same sender and lease can be confirmed in this<br/>                transaction&#x27;s valid rounds<br/>            rekey_to (str, optional): additionally rekey the sender to this address<br/>    <br/>        &quot;&quot;&quot;<br/>        if self.status != AtomicTransactionComposerStatus.BUILDING:<br/>            raise error.AtomicTransactionComposerError(<br/>                &quot;AtomicTransactionComposer must be in BUILDING state for a transaction to be added&quot;<br/>            )<br/>        if len(self.txn_list) + method.get_txn_calls() &gt; self.MAX_GROUP_SIZE:<br/>            raise error.AtomicTransactionComposerError(<br/>                &quot;AtomicTransactionComposer cannot exceed MAX_GROUP_SIZE transactions&quot;<br/>            )<br/>        if app_id == 0:<br/>            if not approval_program or not clear_program:<br/>&gt;               raise error.AtomicTransactionComposerError(<br/>                    &quot;One of the following required parameters for application creation is missing: approvalProgram, clearProgram&quot;<br/><span class="error">E                   algosdk.error.AtomicTransactionComposerError: One of the following required parameters for application creation is missing: approvalProgram, clearProgram</span><br/><br/>venv/lib/python3.10/site-packages/algosdk/atomic_transaction_composer.py:225: AtomicTransactionComposerError<br/></div></td></tr></tbody></table></body></html>